import os
import requests
import fitz  # PyMuPDF
import google.generativeai as genai
from PIL import Image
import json
import io
import time
import zipfile
import re
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4, landscape
from reportlab.lib import colors
from reportlab.pdfbase import pdfmetrics
from reportlab.pdfbase.ttfonts import TTFont
from reportlab.platypus import Paragraph, Frame, KeepInFrame
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.enums import TA_LEFT

class SlideContentExtractor:
    def __init__(self, api_key=None):
        self.api_key = api_key or os.environ.get("GEMINI_API_KEY")
        if not self.api_key:
            raise ValueError("GEMINI_API_KEY is required.")
        genai.configure(api_key=self.api_key)
        # Using Gemini 3 Flash Preview for better reasoning
        self.model = genai.GenerativeModel('gemini-3-flash-preview')
        
        self.font_path = os.path.join(os.path.dirname(__file__), 'data', 'HackGen-Regular.ttf')
        self._ensure_font()

    def _latex_to_reportlab(self, text):
        """Converts basic LaTeX math to ReportLab tags (sub/sup/greek)."""
        if not text: return ""
        
        greek_alphabet = {
            r'\alpha': 'α', r'\beta': 'β', r'\gamma': 'γ', r'\delta': 'δ',
            r'\epsilon': 'ε', r'\zeta': 'ζ', r'\eta': 'η', r'\theta': 'θ',
            r'\iota': 'ι', r'\kappa': 'κ', r'\lambda': 'λ', r'\mu': 'μ',
            r'\nu': 'ν', r'\xi': 'ξ', r'\omicron': 'ο', r'\pi': 'π',
            r'\rho': 'ρ', r'\sigma': 'σ', r'\tau': 'τ', r'\upsilon': 'υ',
            r'\phi': 'φ', r'\chi': 'χ', r'\psi': 'ψ', r'\omega': 'ω',
            r'\Gamma': 'Γ', r'\Delta': 'Δ', r'\Theta': 'Θ', r'\Lambda': 'Λ',
            r'\Pi': 'Π', r'\Sigma': 'Σ', r'\Phi': 'Φ', r'\Omega': 'Ω',
            r'\times': '×', r'\pm': '±', r'\neq': '≠', r'\approx': '≈',
            r'\ell': 'ℓ', r'\cdot': '⋅', r'\infty': '∞'
        }

        def replace_math(match):
            content = match.group(1)
            # Replace Greek letters
            for cmd, char in greek_alphabet.items():
                content = content.replace(cmd, char)

            # Subscripts _{abc} or _a
            content = re.sub(r'\_\{([^}]+)\}', r'<sub>\1</sub>', content)
            content = re.sub(r'\_([a-zA-Z0-9ℓ])', r'<sub>\1</sub>', content)

            # Superscripts ^{abc} or ^a
            content = re.sub(r'\^\{([^}]+)\}', r'<sup>\1</sup>', content)
            content = re.sub(r'\^([a-zA-Z0-9])', r'<sup>\1</sup>', content)
            
            return content

        # Process all $...$ blocks
        text = re.sub(r'\$([^$]+)\$', replace_math, text)
        
        # Remove remaining single backslashes often generated by LLMs incorrectly
        # but keep common markdown bold/italic if needed. 
        # For now, just return.
        return text

    def _ensure_font(self):
        """Downloads Japanese font if not present."""
        if not os.path.exists(os.path.dirname(self.font_path)):
            os.makedirs(os.path.dirname(self.font_path))
            
        if not os.path.exists(self.font_path):
            print("Downloading Japanese font (HackGen)...")
            url = "https://github.com/yuru7/HackGen/releases/download/v2.9.0/HackGen_v2.9.0.zip"
            try:
                resp = requests.get(url)
                resp.raise_for_status()
                with zipfile.ZipFile(io.BytesIO(resp.content)) as z:
                    for name in z.namelist():
                        if name.endswith('HackGen-Regular.ttf'):
                            with z.open(name) as zf, open(self.font_path, 'wb') as f:
                                f.write(zf.read())
                            print("Font extracted.")
                            break
            except Exception as e:
                print(f"Failed to download font: {e}")

        # Register Font
        if os.path.exists(self.font_path):
            try:
                pdfmetrics.registerFont(TTFont('HackGen', self.font_path))
                self.font_name = 'HackGen'
                print(f"Successfully registered font: {self.font_name}")
            except Exception as e:
                print(f"Failed to register font: {e}")
                self.font_name = 'Helvetica'
        else:
            self.font_name = 'Helvetica'

    def _download_pdf(self, pdf_url):
        """Downloads PDF from URL to a bytes buffer."""
        if '/abs/' in pdf_url:
            pdf_url = pdf_url.replace('/abs/', '/pdf/')
        if not pdf_url.endswith('.pdf'):
            pdf_url += '.pdf'
            
        print(f"Downloading PDF from {pdf_url}...")
        resp = requests.get(pdf_url)
        resp.raise_for_status()
        return io.BytesIO(resp.content)

    def _pdf_to_images(self, pdf_stream, num_pages=3):
        """Converts first N pages of PDF to PIL Images."""
        doc = fitz.open(stream=pdf_stream, filetype="pdf")
        images = []
        for i in range(min(num_pages, len(doc))):
            page = doc.load_page(i)
            pix = page.get_pixmap(dpi=150)
            img = Image.open(io.BytesIO(pix.tobytes()))
            images.append(img)
        return images, doc

    def extract_content(self, pdf_url):
        """Extracts content and figures."""
        pdf_stream = self._download_pdf(pdf_url)
        images, doc = self._pdf_to_images(pdf_stream, num_pages=4)
        
        prompt = """
        You are an expert researcher creating a presentation slide for a paper introduction.
        Please read the paper and extract the following information in JAPANESE (except for title_en).
        
        The points MUST be short and concise (suitable for a single PowerPoint slide).
        
        JSON structure:
        {
            "title_en": "Original English Title",
            "title_ja": "日本語のタイトル",
            "authors": "著者名",
            "summary": "どんなもの？/どんな発見？",
            "novelty": "先行研究に比べてどこがすごい？",
            "method_key": "技術や手法のキモはどこ？",
            "validation": "どうやって有効だと検証した？",
            "discussion": "議論はある？",
            "next_paper": "次に読むべき論文は？",
            "figure1": { "page_index": 0, "bbox": [ymin, xmin, ymax, xmax] },
            "figure2": { "page_index": 0, "bbox": [ymin, xmin, ymax, xmax] }
        }
        
        CRITICAL: 
        - title_en: MUST BE the original English title from the paper.
        - figure1: ARCHITECTURE/METHOD Diagram.
        - figure2: RESULT/Qualitative comparison.
        - OUTPUT VALID JSON. Escape backslashes.
        """
        
        print("Sending images to Gemini...")
        response = self.model.generate_content([prompt, *images])
        
        try:
            text = response.text.strip()
            if text.startswith("```json"): text = text[7:]
            if text.startswith("```"): text = text[3:]
            if text.endswith("```"): text = text[:-3]
            
            data = json.loads(text.strip())
            print("Extracted Data:", json.dumps(data, indent=2, ensure_ascii=False))
            
            # Helper to crop
            def crop_fig(fig_key):
                fig_info = data.get(fig_key)
                if not fig_info: return None
                page_idx = fig_info.get("page_index", 0)
                if 0 <= page_idx < len(images):
                    target_img = images[page_idx]
                    w, h = target_img.size
                    ymin, xmin, ymax, xmax = fig_info["bbox"]
                    left = (xmin / 1000) * w
                    top = (ymin / 1000) * h
                    right = (xmax / 1000) * w
                    bottom = (ymax / 1000) * h
                    return target_img.crop((left, top, right, bottom))
                return None

            img1 = crop_fig("figure1")
            img2 = crop_fig("figure2")
            
            # ArXiv Link (derived from pdf_url)
            arxiv_url = pdf_url.replace('/pdf/', '/abs/').replace('.pdf', '')
            
            return {
                "meta": data, 
                "image1": img1, 
                "image2": img2, 
                "arxiv_url": arxiv_url
            }

        except Exception as e:
            print(f"Error parsing Gemini response: {e}")
            return None

    def generate_slides_for_papers(self, papers, output_path):
        """Generates a PDF with one page per paper."""
        print(f"Generating PDF with font: {self.font_name}")
        c = canvas.Canvas(output_path, pagesize=landscape(A4))
        w, h = landscape(A4)
        
        # Title Page
        c.setFont(self.font_name, 30)
        c.drawCentredString(w/2, h/2 + 20, "ArXiv Paper Digest")
        c.setFont(self.font_name, 16)
        c.drawCentredString(w/2, h/2 - 20, f"Generated on {time.strftime('%Y-%m-%d')}")
        c.showPage()
        
        for i, paper in enumerate(papers):
            url = paper.get('url')
            if not url: continue
            
            print(f"Processing ({i+1}/{len(papers)}): {paper.get('title', 'Unknown')}")
            try:
                # We could pass paper.get('title') here to ensure original title, 
                # but letting Gemini extract it from PDF is also good.
                data = self.extract_content(url)
                if data:
                    try:
                        self._draw_paper_slide(c, data)
                    except Exception as e:
                        print(f"Error drawing slide for {url}: {e}")
                        # Optionally draw error message on slide
                        c.setFont("Helvetica", 12)
                        c.drawString(100, 100, f"Error rendering content: {e}")
                    
                    # Ensure we finish the page regardless of drawing success
                    c.showPage()
                else:
                    print(f"Failed to extract content for {url}")
                    # If we want to skip this paper entirely, do nothing. 
                    # The canvas is clean for the next paper.
            except Exception as e:
                print(f"Error processing {url}: {e}")
                
        c.save()
        return output_path

    def _draw_paper_slide(self, c, data):
        """Draws content on the current canvas page."""
        meta = data['meta']
        image1 = data.get('image1')
        image2 = data.get('image2')
        arxiv_url = data.get('arxiv_url', '')
        
        w, h = landscape(A4) # w=841, h=595
        margin = 25
        
        # Styles
        title_style = ParagraphStyle(
            'Title', fontName=self.font_name, fontSize=18, leading=22, wordWrap='CJK', spaceAfter=5)
        header_style = ParagraphStyle(
            'Header', fontName=self.font_name, fontSize=12, leading=14, textColor=colors.darkblue, wordWrap='CJK', spaceBefore=6)
        body_style = ParagraphStyle(
            'Body', fontName=self.font_name, fontSize=10, leading=13, wordWrap='CJK', leftIndent=10)
        link_style = ParagraphStyle(
            'Link', fontName=self.font_name, fontSize=9, textColor=colors.blue, spaceBefore=2)
        
        # Title & Authors (Top Row)
        # Use English Title
        display_title = meta.get('title_en') or meta.get('title_ja', 'No Title')
        title_text = f"<b>{display_title}</b><br/><font size=10 color=grey>{meta.get('authors', '')}</font>"
        title_p = Paragraph(title_text, title_style)
        title_w, title_h = title_p.wrap(w - 2*margin, 100)
        title_p.drawOn(c, margin, h - margin - title_h)
        
        # arXiv Link
        link_html = f'<link href="{arxiv_url}">{arxiv_url}</link>'
        link_p = Paragraph(link_html, link_style)
        lw, lh = link_p.wrap(w - 2*margin, 20)
        link_p.drawOn(c, margin, h - margin - title_h - lh - 2)
        
        content_top_y = h - margin - title_h - lh - 15
        
        # Layout: Left Column (Text 55%), Right Column (Images 45%)
        col_gap = 20
        col_text_w = (w - 2*margin - col_gap) * 0.55
        col_img_w = (w - 2*margin - col_gap) * 0.45
        
        # --- Left: Text Content ---
        text_frame = Frame(margin, margin, col_text_w, content_top_y - margin, showBoundary=0, topPadding=0)
        story = []
        
        def add_point(title, text_content):
            story.append(Paragraph(title, header_style))
            if isinstance(text_content, list):
                text_content = " ".join(text_content)
            
            # Apply LaTeX filter and clean newlines
            clean_content = self._latex_to_reportlab(str(text_content))
            clean_content = clean_content.replace('\n', ' ')
            
            story.append(Paragraph(clean_content, body_style))

        add_point("■ どんなもの？", meta.get('summary', ''))
        add_point("■ 先行研究に比べてどこがすごい？", meta.get('novelty', ''))
        add_point("■ 技術や手法のキモはどこ？", meta.get('method_key', ''))
        add_point("■ どうやって有効だと検証した？", meta.get('validation', ''))
        add_point("■ 議論はある？", meta.get('discussion', ''))
        add_point("■ 次に読むべき論文は？", meta.get('next_paper', ''))
        
        text_frame.addFromList(story, c)
        
        # --- Right: Images ---
        img_x = margin + col_text_w + col_gap
        img_area_h = content_top_y - margin
        
        def draw_image_in_box(img_obj, x, y, box_w, box_h):
            if not img_obj: return
            from reportlab.lib.utils import ImageReader
            img_reader = ImageReader(img_obj)
            iw, ih = img_reader.getSize()
            aspect = iw / ih
            draw_w = box_w
            draw_h = draw_w / aspect
            if draw_h > box_h:
                draw_h = box_h
                draw_w = draw_h * aspect
            
            offset_x = x + (box_w - draw_w) / 2
            offset_y = y + (box_h - draw_h) / 2
            c.drawImage(img_reader, offset_x, offset_y, width=draw_w, height=draw_h)
            c.rect(offset_x, offset_y, draw_w, draw_h, stroke=1, fill=0)

        box_h = (img_area_h - 10) / 2
        
        # Image 1 (Top)
        if image1:
            draw_image_in_box(image1, img_x, margin + box_h + 10, col_img_w, box_h)
            c.setFont(self.font_name, 8)
            c.drawString(img_x, margin + box_h + 10 - 10, "Fig 1: Method/Arch")

        # Image 2 (Bottom)
        if image2:
            draw_image_in_box(image2, img_x, margin, col_img_w, box_h)
            c.setFont(self.font_name, 8)
            c.drawString(img_x, margin - 10, "Fig 2: Result")

if __name__ == "__main__":
    test_url = "https://arxiv.org/abs/2601.05328" 
    extractor = SlideContentExtractor()
    result = extractor.extract_content(test_url)
    if result:
        # Hack to test single slide gen within list function or just manual
        # extractor.generate_slides_for_papers([{'url': test_url, 'title': 'Test'}], "test_slides.pdf")
        # Let's run the full single method manually for testing
        c = canvas.Canvas("test_slide.pdf", pagesize=landscape(A4))
        extractor._draw_paper_slide(c, result)
        c.showPage()
        c.save()
        print("Saved test_slide.pdf")
